use collections::HashMap;
use convert_case::{Case, Casing};
use serde::{Deserialize, Serialize};
use serde_json::Result;
use std::{
    collections,
    fs::{self, DirEntry},
    io,
    path::Path,
};

#[derive(Serialize, Deserialize, Debug)]
struct Attr {
    is_branch: Option<bool>,
    is_segment: Option<bool>,
    is_keyword: Option<bool>,
    is_condition: Option<bool>,
    is_nop: Option<bool>,
    is_unsupported: Option<bool>,
    is_constructor: Option<bool>,
    is_destructor: Option<bool>,
    is_static: Option<bool>,
    is_overload: Option<bool>,
    is_variadic: Option<bool>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Param {
    r#type: String,
    r#name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Command {
    id: String,
    name: String,
    attrs: Attr,
    num_params: i32,
    input: Option<Vec<Param>>,
    output: Option<Vec<Param>>,
    class: Option<String>,
    member: Option<String>,
    short_desc: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Extension {
    name: String,
    commands: Vec<Command>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Meta {
    last_update: u64,
}

#[derive(Serialize, Deserialize, Debug)]
struct Library {
    meta: Meta,
    extensions: Vec<Extension>,
}

fn visit_dirs(dir: &Path, cb: &mut dyn FnMut(&DirEntry) -> Option<()>) -> io::Result<()> {
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                visit_dirs(&path, cb)?;
            } else {
                cb(&entry);
            }
        }
    }
    Ok(())
}

fn generate_snippets() -> io::Result<()> {
    let mut snippets: HashMap<String, HashMap<String, String>> = HashMap::new();
    let args: Vec<String> = std::env::args().collect();
    let source_dir = args
        .get(2)
        .unwrap_or_else(|| panic!("Provide source directory path"));

    visit_dirs(&Path::new(source_dir), &mut |f| -> Option<()> {
        let content = fs::read_to_string(f.path()).ok()?;
        let path = f.path();
        let mut c = path.components();

        let extension: String = c.nth_back(1)?.as_os_str().to_str()?.into();
        let map = snippets.entry(extension).or_insert(HashMap::new());
        map.insert(f.path().file_stem()?.to_str()?.into(), content);
        Some(())
    })?;

    let json = serde_json::to_string_pretty(&snippets)?;
    println!("{}", json);

    Ok(())
}

fn generate_classes() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();
    let input_file = args
        .get(2)
        .unwrap_or_else(|| panic!("Provide input file name"));

    let content = fs::read_to_string(input_file).unwrap();
    let library = serde_json::from_str::<Library>(content.as_str())?;

    let commands = library
        .extensions
        .iter()
        .flat_map(|ext| ext.commands.iter())
        .collect::<Vec<_>>();

    let mut classes_list: HashMap<String, HashMap<String, String>> = HashMap::new();

    for command in commands {
        if !command.class.is_some() || !command.member.is_some() {
            continue;
        }

        let class_name = command.class.as_ref().unwrap().to_case(Case::Pascal);
        let class_member = command.member.as_ref().unwrap().to_case(Case::Pascal);

        if !classes_list.contains_key(&class_name) {
            classes_list.insert(class_name.clone(), HashMap::new());
        }

        let map = classes_list.get_mut(&class_name).unwrap();

        let is_condition = if command.attrs.is_condition.is_some() {
            1
        } else {
            0
        };

        let params: Vec<String> = command
            .input
            .as_ref()
            .unwrap_or(&Vec::new())
            .iter()
            .chain(command.output.as_ref().unwrap_or(&Vec::new()).iter())
            .map(|p| {
                if p.name.len() == 0 {
                    String::from("")
                } else {
                    let _type = match p.r#type.to_ascii_lowercase().as_str() {
                        "float" => String::from("%f"),
                        "int" => String::from("%i"),
                        "string" => String::from("%s"),
                        "bool" | "boolean" => String::from("%b"),
                        _ => format!(": {}", p.r#type),
                    };
                    format!("\"{}{}\"", p.name, _type)
                }
            })
            .collect();

        let description = format!(
            "{},{},{},({})",
            command.id.trim(),
            is_condition,
            0,
            params.join(" ")
        );
        map.insert(class_member, description);
    }

    let mut classes_names: Vec<&str> = classes_list.keys().map(|line| line.trim()).collect();
    classes_names.sort();

    println!("; autogenerated from {}\n", input_file);
    println!("#CLASSESLIST");

    for class_name in classes_names.iter() {
        println!("{}", class_name);
    }

    println!("\n#CLASSES");

    for &class_name in classes_names.iter() {
        println!("${}", class_name.trim());
        println!("$BEGIN");

        let members = classes_list.get(class_name).unwrap();
        let mut member_names: Vec<&String> = members.keys().collect();
        member_names.sort();

        for member_name in member_names {
            let description = members.get(member_name).unwrap();
            println!("{},{}", member_name, description);
        }

        println!("$END\n");
    }

    println!("#EOF");

    Ok(())
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    match args.get(1) {
        Some(x) if x == "classes" => generate_classes().ok(),
        Some(x) if x == "snippets" => generate_snippets().ok(),
        Some(x) => {
            panic!("unknown action argument {}", x);
        }
        None => {
            panic!("missing action argument");
        }
    };
}
